###对于做vue的响应式，问自己的内心的几个问题如下：
####1）怎么做的数据劫持，vue2和 vue3的区别？
答： vue2的数据劫持是使用是es5的 Object.defineProperty的setter 和 getter方法来对对于数据的读取和设置的， 但是这里有一个最大的缺陷是 需要遍历对象的每一个属性进行setter 和 getter, 对于大数据量，或者说是复杂的组件不友好，还有就是对象里面新增属性或者说是删除对象属性做不了数据劫持，所以vue2.0提出了 vue.$set 和 vue.$delete ； 
vue3的数据劫持使用的是 Proxy(代理) 来实现的，可以对大数据量的setter 和 getter, 由于每个对象的getter 返回的都是一个代理， 这使得代理可以缓存，使得大数据也是可以的，缺点是ie中的浏览器是没有es6的proxy(IE浏览器得es6转换成es5得问题),vue3.0对ie的低版本不怎么友好，目前ie11是可以打开vue3.0 创建的项目的


####问题：简述vue2和vue3分别是如何实现响应式的？vue3在响应式上的提升在哪里？
vue2的响应式是使用Object.defineProperty完成的，它会对原始对象有侵入。
在创建响应式阶段，会递归遍历原始对象的所有属性，当对象属性较多、较深时，对效率的影响颇为严重。不仅如此，由于遍历属性仅在最开始完成，因此在这儿之后无法响应属性的新增和删除。
在收集依赖时，vue2采取的是构造函数的办法，构造函数是一个整体，不利于tree shaking。

vue3的响应式是使用Proxy完成的，它不会侵入原始对象，而是返回一个代理对象，通过操作代理对象完成响应式。
由于使用了代理对象，因此并不需要遍历原始对象的属性，只需在读取属性时动态的决定要不要继续返回一个代理，这种按需加载的模式可以完全无视对象属性的数量和深度，达到更高的执行效率。
由于ES6的Proxy可以代理更加底层的操作，因此对属性的新增、删除都可以完美响应。
在收集依赖时，vue3采取的是普通函数的做法，利用高效率的WeakMap实现依赖记录，这利于tree shaking，从而降低打包体积。
